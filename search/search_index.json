{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Geodepot \u2013 Test data storage system for geospatial data","text":"<p>Spatial data processing software are often tested against real-world data that is difficult to fake. Consider for example a particularly nasty polygon or a particular configuration of triangles. Such input is often too large to check into the version control system along with the source code, so we might end up storing them in a separate location. As time passes and the software evolves, it is easy to forget about the purpose of the data and loose track of it. Collecting and organizing good test data is a tedious, time consuming process, and it is best not to waste the effort.</p> <p>Geodepot helps to organize data into test cases, share them and provide integration to some of the test frameworks for ease of use. It was born from our own experience of writing spatial data processing tools over the past years.</p>"},{"location":"#example","title":"Example","text":"<p>The minimal example below gives and idea of how Geodepot works.</p> <p>Initialize an empty repository in the current working directory.</p> <pre><code>geodepot init\n</code></pre> <p>Add some data to this repository. The GeoPackage file <code>path/to/local/wippolder.gpkg</code> is added to the case <code>wippolder</code> with the name <code>wippolder.gpkg</code>, and the provided license and description are attached to the data entry.</p> <pre><code>geodepot add \\\n  --license CC0 \\\n  --description \"A couple of buildings and a church in Delft for minimal testing.\" \\\n  wippolder \\\n  path/to/local/wippolder.gpkg\n</code></pre> <p>When writing a test, use one of the API functions to get the full path to the data.</p> C++PythonCMake <pre><code>#include &lt;geodepot/geodepot.h&gt;\n\nint main(void) {\n  auto repo = geodepot::Repository(\n      \"https://data.3dgi.xyz/geodepot-test-data/mock_project/.geodepot\");\n  auto p = repo.get(\"wippolder/wippolder.gpkg\");\n  return 0;\n}\n</code></pre> <pre><code>from geodepot import Repository\n\ndef main():\n    repo = Repository(\"https://data.3dgi.xyz/geodepot-test-data/mock_project/.geodepot\")\n    p = repo.get(\"wippolder/wippolder.gpkg\")\n</code></pre> <pre><code>include(GeoDepot)\n\nGeodepotInit(\"https://data.3dgi.xyz/geodepot-test-data/mock_project/.geodepot\")\nGeodepotGet(\"wippolder/wippolder.gpkg\")\n\n# add executables, entable tests etc...\n\n# The GEODEPOT_DIR variable stores the path to the data in the repository that was \n# initialized and downloaded by GeodepotInit and GeodepotGet\nadd_test(\n      NAME \"function-using-geodepot-data\"\n      COMMAND test_geodepot_cmake \"${GEODEPOT_DIR}/wippolder/wippolder.gpkg\"\n      WORKING_DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}\")\n</code></pre> <p>Alternatively, you can also use the CLI to get the data path.</p> <pre><code>geodepot get wippolder/wippolder.gpkg\n</code></pre>"},{"location":"#interfaces","title":"Interfaces","text":""},{"location":"#command-line-tool-cli","title":"Command-line tool (CLI)","text":"<p>The main interface. It supports all operations and you are currently reading its documentation.</p> <p>Repository: https://github.com/3DBAG/geodepot</p>"},{"location":"#api","title":"API","text":"<p>The API is meant for passing data paths to tests, nothing else. The rest of the operations are done through the CLI.</p> <p>The API is available in:</p> <ul> <li>C++ (implementation)</li> <li>Python (binding)</li> <li>CMake (binding)</li> </ul> <p>Repository: https://github.com/3DBAG/geodepot-api</p>"},{"location":"#what-geodepot-is-not","title":"What Geodepot is not","text":"<p>Geodepot is not a version control system, neither for data nor for code. It is assumed that the data that you store in a Geodepot repository is already available, and will stay available in some other form. Thus, if the repository is accidentally overwritten with unwanted changes, the desired state can be recreated with some effort. That is, because the history of the repository is not retained, only the latest version is available at any time.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>The current version (<code>1</code>) is considered to be feature complete, and there are no major enhancements planned. This does not mean however, that the current version is bug free. The ongoing development focuses on fixing bugs reported by users or discovered during testing.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#init","title":"Init","text":"<p>Initialize a local repository from an existing Geodepot repository. The constructor take a path to a local directory or a URL to a remote directory. The path must contain a valid Geodepot repository. After initialization, the data items in this repository can be downloaded and used in the tests.</p> C++PythonCMake <pre><code>#include &lt;geodepot/geodepot.h&gt;\n\nint main(void) {\n  auto repo = geodepot::Repository(\n      \"https://data.3dgi.xyz/geodepot-test-data/mock_project\");\n}\n</code></pre> <pre><code>from geodepot import Repository\n\ndef main():\n    repo = Repository(\"https://data.3dgi.xyz/geodepot-test-data/mock_project\")\n</code></pre> <pre><code>include(GeoDepot)\n\nGeodepotInit(\"https://data.3dgi.xyz/geodepot-test-data/mock_project\")\n</code></pre>"},{"location":"api/#get","title":"Get","text":"<p>Once the repository has been initialized, it is possible to get the full local path to a data item. If the data is not available locally, it will be downloaded from the remote on the first call if the function.</p> C++PythonCMake <pre><code>std::filesystem::path p = repo.get(\"wippolder/wippolder.gpkg\");\n</code></pre> <pre><code>p = repo.get(\"wippolder/wippolder.gpkg\")\n</code></pre> <p>Geodepot sets the <code>GEODEPOT_DIR</code> CMake cache variable to the path to the initialized geodepot repository. In order obtain the full path to a data item, construct the path as <code>${GEODEPOT_DIR}/&lt;case name&gt;/&lt;data name&gt;</code>.</p> <pre><code>GeodepotGet(\"wippolder/wippolder.gpkg\")\n\n# add executables, entable tests etc...\n\nadd_test(\n      NAME \"function-using-geodepot-data\"\n      COMMAND test_geodepot_cmake \"${GEODEPOT_DIR}/wippolder/wippolder.gpkg\"\n      WORKING_DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}\")\n</code></pre>"},{"location":"cli/","title":"Command-line tool","text":""},{"location":"cli/#geodepot","title":"geodepot","text":"<p>Test data storage system for geospatial data</p> <p>Usage</p> <pre><code>geodepot [OPTIONS] &lt;COMMAND&gt;\n</code></pre> <p>Commands</p> <p><code>geodepot add</code>: Add or update a case or a data item.</p> <p><code>geodepot config</code>: Query or set Geodepot configuration values.</p> <p><code>geodepot fetch</code>: Compare the local repository against a remote.</p> <p><code>geodepot get</code>: Return the full local path to the specified data item of the specified case.</p> <p><code>geodepot init</code>: Initialise a Geodepot repository in the current directory.</p> <p><code>geodepot list</code>: List the cases and data items in the repository.</p> <p><code>geodepot pull</code>: Download any changes from a remote repository and overwrite the local version.</p> <p><code>geodepot push</code>: Upload any local changes to a remote repository and overwrite the remote version.</p> <p><code>geodepot remote</code>: Connect an existing remote Geodepot repository.</p> <p><code>geodepot remove</code>: Delete a case or a data entry from the repository.</p> <p><code>geodepot show</code>: Show the details of the specified case or data.</p>"},{"location":"cli/#add","title":"add","text":"<p>Synopsis</p> <pre><code>geodepot add [-y] [--license=&lt;text&gt;] [--description=&lt;text&gt;] [--format=&lt;format&gt;] [--as-data] [&lt;pathspec&gt;...] &lt;casespec&gt;\n</code></pre> <p>Description</p> <p>Add or update a case or a data item. In each operation, the case will be created if it does not exist. In each operation, existing values, data files are updated with the newly provided.</p> <p>Options</p> <p><code>&lt;casespec&gt;</code>: Case (and data) specifier, in the form of <code>case-name[/data-name]</code>. Providing the case name <code>case-name</code> is mandatory, the data name <code>data-name</code> within the case is optional. The rest of the options will affect the specified level, either the whole case with <code>case-name</code>, or just a single data within the case with <code>case-name/data-name</code>. For example, <code>wippolder/wippolder.gpkg</code>, where <code>wippolder</code> is the case name, <code>wippolder.gpkg</code> is the data name.</p> <p><code>&lt;pathspec&gt;</code>: Path specifier for the data files to add to the case. Can be a path to a single file, a directory or a fileglob (e.g. <code>*.gpkg</code>). Can be passed multiple times. Only local files are supported.</p> <p><code>-y</code>: Do not require confirmation for updating existing values or files.</p> <p><code>--license=&lt;text&gt;</code>: A license to add to the data.</p> <p><code>--description=&lt;text&gt;</code>: A description to add to the case or data.</p> <p><code>--format=&lt;format&gt;</code>: A format to force on the data in case it cannot be inferred automatically, or the inferred format is not correct. If the a whole directory is added as a single data entry with <code>--as-data</code>, the automatic format inference doesn't work, and it may be necessary to force a format. Note that when the format is forced, the bounding box calculation and hashing does not work.</p> <p><code>--as-data</code>: Add a whole directory as a single data entry. The default behaviour is to add each file in the directory as a separate data entry. If <code>--as-data</code> is set, the bounding box and file hash cannot be computed for the data.</p> <p>Examples</p> <p>Add multiple files as data entries to a case. If the case does not exist, it will be created as <code>case-name</code> and the file <code>file-name</code> is moved into it.</p> <pre><code>geodepot add /path/to/file-name1 /path/to/file-name2 case-name\n</code></pre> <p>Update the license and description of a data entry (<code>file-name</code>) in a case (<code>case-name</code>).</p> <pre><code>geodepot add --description \"long description\\nmultiline\" --license \"CC-0\" case-name/file-name1\n</code></pre> <p>Update the description of a case (<code>case-name</code>)</p> <pre><code>geodepot add --description \"new description of the case\" case-name\n</code></pre>"},{"location":"cli/#fetch","title":"fetch","text":"<p>Synopsis</p> <pre><code>geodepot fetch &lt;name&gt;\n</code></pre> <p>Description</p> <p>Compare the local repository against the remote <code>&lt;name&gt;</code>. The differences are printed to the console.</p>"},{"location":"cli/#config","title":"config","text":"<p>Synopsis</p> <pre><code>geodepot config list\ngeodepot config get [--global] &lt;name&gt;\ngeodepot config set [--global] &lt;name&gt; &lt;value&gt;\n</code></pre> <p>Description</p> <p>Query or set Geodepot configuration values. The <code>name</code> is actually the section and the key separated by a dot, and the <code>value</code> will be escaped.</p> <p>Options</p> <p><code>--global</code>: For writing options: write to the global <code>~/.geodepotconfig</code> file rather than the repository <code>.geodepot/config</code>.</p> <p>For reading options: read only from the global <code>~/.geodepotconfig</code> file rather than the repository <code>.geodepot/config</code>.</p> <p>Examples</p> <pre><code>geodepot config add --global user.name \"Kov\u00e1cs J\u00e1nos\"\ngeodepot config add --global user.email janos@kovacs.me\n</code></pre>"},{"location":"cli/#config-list","title":"config list","text":"<p>List all variables set in the config files, along with their values.</p>"},{"location":"cli/#config-get","title":"config get","text":"<p>Emits the value of the specified key. If key is present multiple times in the configuration, emits the last value.</p>"},{"location":"cli/#config-set","title":"config set","text":"<p>Set the value for one configuration option.</p>"},{"location":"cli/#get","title":"get","text":"<p>Synopsis</p> <pre><code>geodepot get &lt;casespec&gt;\n</code></pre> <p>Description</p> <p>Return the full local path to the specified data item of the specified case. If the data item does not exist locally and a remote repository is configured, the data will be downloaded from the remote.</p> <p>Options</p> <p><code>&lt;casespec&gt;</code>: Case (and data) specifier, in the form of <code>case-name/data-name</code>. For example, <code>wippolder/wippolder.gpkg</code>, where <code>wippolder</code> is the case name, <code>wippolder.gpkg</code> is the data name.</p> <p>Examples</p> <p>Get the full local path to the data item <code>wippolder/wippolder.gpkg</code>.</p> <pre><code>geodepot get wippolder/wippolder.gpkg\n</code></pre>"},{"location":"cli/#init","title":"init","text":"<p>Synopsis</p> <pre><code>geodepot init [url]\n</code></pre> <p>Description</p> <p>Initialise a Geodepot repository in the current directory.</p> <p>Options</p> <p>Without arguments, initialise an empty local repository in the current directory.</p> <p>With a URL to a remote repository as an argument, <code>geodepot init &lt;url&gt;</code>, download the remote repository except its data files, to make it available locally. The data needs to be <code>pull</code>-ed explicitly after the repository has been initialised.</p>"},{"location":"cli/#list","title":"list","text":"<p>Synopsis</p> <pre><code>geodepot list\n</code></pre> <p>Description</p> <p>List the cases and data items in the repository.</p>"},{"location":"cli/#pull","title":"pull","text":"<p>Synopsis</p> <pre><code>geodepot pull [--yes] &lt;name&gt;\n</code></pre> <p>Description</p> <p>Download any changes from the remote repository <code>&lt;name&gt;</code>, overwriting the local version. Geodepot lists the differences between the local and remote, by calling <code>geodepot fetch</code> internally and asks for confirmation before overwriting the local.</p> <p>Options</p> <p><code>--yes / -y</code>: Automatically overwrite the local without asking for confirmation.</p>"},{"location":"cli/#push","title":"push","text":"<p>Synopsis</p> <pre><code>geodepot push [--yes] &lt;name&gt;\n</code></pre> <p>Description</p> <p>Upload any local changes to the remote repository <code>&lt;name&gt;</code>, overwriting the remote version. Geodepot lists the differences between the local and remote, by calling <code>geodepot fetch</code> internally and asks for confirmation before overwriting the remote.</p> <p>Options</p> <p><code>--yes / -y</code>: Automatically overwrite the remote without asking for confirmation.</p>"},{"location":"cli/#remote","title":"remote","text":"<p>Synopsis</p> <pre><code>geodepot remote list\ngeodepot remote add &lt;name&gt; &lt;url&gt;\ngeodepot remote remove &lt;name&gt;\n</code></pre> <p>Description</p> <p>Connect an existing remote Geodepot repository.</p> <p>Examples</p> <pre><code>geodepot remote add origin https://data.3dgi.xyz/geodepot-test-data/mock_project/.geodepot\n</code></pre>"},{"location":"cli/#remote-list","title":"remote list","text":"<p>List the available remote repositories.</p>"},{"location":"cli/#remote-add","title":"remote add","text":"<p>Add a remote repository to track. The remote repository must exist.</p>"},{"location":"cli/#remote-remove","title":"remote remove","text":"<p>Remove the remote from the tracked remotes. The remote repository is not deleted.</p>"},{"location":"cli/#remove","title":"remove","text":"<p>Synopsis</p> <pre><code>geodepot remove [-y] [&lt;casespec&gt;...]\n</code></pre> <p>Description</p> <p>Delete a case or a data entry from the repository.</p> <p>Options</p> <p><code>&lt;casespec&gt;</code>: Case (and data) specifier, in the form of <code>case-name[/data-name]</code>. Can be specified multiple times. Providing the case name <code>case-name</code> is mandatory, the data name <code>data-name</code> within the case is optional. The rest of the options will affect the specified level, either the whole case with <code>case-name</code>, or just a single data within the case with <code>case-name/data-name</code>. For example, <code>wippolder/wippolder.gpkg</code>, where <code>wippolder</code> is the case name, <code>wippolder.gpkg</code> is the data name.</p> <p><code>-y</code>: Do not require confirmation for deleting the entries.</p>"},{"location":"cli/#show","title":"show","text":"<p>Synopsis</p> <pre><code>geodepot show &lt;casespec&gt;\n</code></pre> <p>Description</p> <p>Show the details of the specified case or data.</p>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#configuration","title":"Configuration","text":"<p>Geodepot uses configuration files to store user information and remotes, among other things.</p> <p>You can specify Geodepot configuration settings with the <code>geodepot config</code> command. Geodepot looks for configuration values on two levels, global and local.</p> <p>Geodepot first looks for the configuration in the <code>~/.geodepotconfig.json</code> file, which is specific to each user. You can make Geodepot read and write to this file by passing the <code>--global</code> option.</p> <p>Secondly, Geodepot looks for configuration values in the configuration file in the Geodepot directory (<code>.geodepot/config.json</code>) of whatever repository you are currently using. These values are specific to that single repository and they are read and written by passing the <code>--local</code> option. This is the default option of the <code>geodepot config</code> command.</p> <p>The local level config overwrites the values of the global level config.</p>"},{"location":"concepts/#user","title":"User","text":"<p>The user information consists of a name and an e-mail address and it is registered in the local HOME directory of the User. The user information is used for identifying changes and locks.</p> <p>Set the user information with the <code>config</code> command.</p> <pre><code>geodepot config --global user.name \"My Name\"\ngeodepot config --global user.email \"my@email.me\"\n</code></pre>"},{"location":"concepts/#repository","title":"Repository","text":"<p>A repository is a collection of related cases that are used as data in software testing. Normally, there is one repository per project, storing all the data that are required by the tests of the project. For example, the projects 3dbag-pipeline and geoflow-roofer would each have their own Geodepot repository.</p> <p>The repository is itself is stored in a <code>.geodepot</code> directory, which is normally located in the software project directory.</p> <p>If you are using Git, or any other version control system, don't forget to exclude the <code>.geodepot</code> directory.</p>"},{"location":"concepts/#index","title":"Index","text":"<p>The repository organises the cases with its index. The index stores the overview of all cases in the repository.</p>"},{"location":"concepts/#case","title":"Case","text":"<p>A case is an organizational unit of related data items. A case is identified by its name. Examples of a case include a bug report with its related files, a particular area in several data formats etc.</p>"},{"location":"concepts/#data-item","title":"Data (item)","text":"<p>A data item is the actual file or directory that contains the data that is used in a test. Data items retain their own format when added to the repository, therefore they can be read directly with their format-specific readers.</p> <p>When the data path is requested, Geodepot returns the full path to the local data file in the repository.</p>"},{"location":"concepts/#remote","title":"Remote","text":"<p>A Geodepot repository on a remote server. By connecting, 'referencing' a remote to your local repository, it is possible to share the data items with other users. A remote is added with the <code>geodepot remote add</code> command.</p>"},{"location":"concepts/#conflict-resolution-between-local-and-remote-repositories","title":"Conflict resolution between local and remote repositories","text":"<p>Geodepot does not retain version history for the data items, nor can it merge different versions of a data item. Therefore, Geodepot does not resolve conflicts automatically.</p> <p>In short, Geodepot know two alternatives to resolve conflicts, either overwrite the local with the remote data (<code>pull</code>), or overwrite the remote with the local data (<code>push</code>).</p> <p>Both of these operations list the detected differences between the local and remote, together with the user that made the last change. The underlying assumption is that a single Geodepot repository is shared by users who have direct contact with each other, e.g. a team. Therefore, if it is not clear whether it is safe to overwrite the local/remote with the changes, the users should discuss with each other how to resolve the conflict manually.</p> <p>Example</p> <p>Both UserA and UserB are working with the same remote repository, Server. Each of the three repositories contain the same data item, <code>wippolder/wippolder.gpkg</code>. UserA removes a few objects from <code>wippolder/wippolder.gpkg</code> and updates the data item in her local repository, but does not push the changes to Server. In the meantime, UserB changes the description of <code>wippolder/wippolder.gpkg</code> and immediately pushes the changes to Server. After a while, UserA decides to push her changes and Geodepot reports that the data <code>wippolder/wippolder.gpkg</code> on Server differs from her local version in its,</p> <ul> <li>description, because UserB changed it,</li> <li>extent, because UserB pushed a version which still contained the objects that UserA removed,</li> <li>sha1, because the file itself has changed</li> <li>changed_by shows UserB, because he made the last change on the version that is on the Server.</li> </ul> <p>At this point, UserA and UserB need to agree on a common version for <code>wippolder/wippolder.gpkg</code>, push it to the Server and update their local versions with it.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#command-line-tool","title":"Command line tool","text":"<p>Download the precompiled executable from the latest release, uncompress it and run the <code>geodepot</code> executable in the <code>geodepot</code> directory. Note that the <code>geodepot</code> executable must remain in the <code>geodepot</code> directory, because it uses relative links to it's dependencies.</p> <p>Geodepot has complex dependencies, so do not <code>pip install</code> it, unless you are developing Geodepot itself. Use the provided binaries instead.</p>"},{"location":"getting-started/#api","title":"API","text":"C++PythonCMake <p>If you are using CMake, use <code>FetchContent</code> (or CPM) and link against <code>geodepot</code>.</p> <p>Using CMake's <code>FetchContent</code>.</p> <pre><code>FetchContent_Declare(\n  geodepot-api\n  GIT_REPOSITORY https://github.com/3DBAG/geodepot-api.git\n)\nFetchContent_MakeAvailable(geodepot-api)\n\nadd_executable(\"test_integration\" \"test_integration.cpp\")\ntarget_link_libraries(\"test_integration\" geodepot)\n</code></pre> <p>Using CPM.</p> <pre><code>CPMAddPackage(\"gh:3dbag/geodepot-api@1.0.4\")\n</code></pre> <p>Use pip to build the Geodepot API and install the bindings.</p> <pre><code>git clone https://github.com/3DBAG/geodepot-api.git\ncd geodepot-api\npip install .\n</code></pre> <p>To add the Geodepot CMake functions to your current project, simply add the latest release of <code>GeoDepot.cmake</code> to your project's <code>cmake</code> directory, then include it. Make sure you include all modules from the <code>cmake</code> directory.</p> <pre><code>include(GeoDepot)\n</code></pre>"},{"location":"getting-started/#first-time-setup","title":"First time setup","text":""},{"location":"getting-started/#configure-your-user","title":"Configure your user","text":"<p>The user information helps to identify changes and locks when working with a remote repository. It consists of a name and an e-mail address and it is stored in the local HOME directory of the user.</p> <pre><code>geodepot config --global user.name \"My Name\"\ngeodepot config --global user.email \"my@email.me\"\n</code></pre>"},{"location":"getting-started/#initialize-a-repository","title":"Initialize a repository","text":"<p>A local Geodepot repository can be created empty, or from an existing remote repository.</p> <p>Navigate to the project directory where you want to initialize a Geodepot repository. Normally, this would be the software project directory.</p> <p>Create an empty repository.</p> <pre><code>geodepot init\n</code></pre> <p>Download and existing repository. Note that <code>init</code> does not download the data items, only the repository index. The data will be downloaded either by calling <code>get</code> the first time, or <code>pull</code>-ing the remote repository.</p> <pre><code>geodepot init https://data.3dgi.xyz/geodepot-test-data/mock_project/.geodepot\n</code></pre>"},{"location":"getting-started/#manage-test-cases","title":"Manage test cases","text":""},{"location":"getting-started/#add-data","title":"Add data","text":"<p>The GeoPackage file <code>path/to/local/wippolder.gpkg</code> is added to the case <code>wippolder</code> with the name <code>wippolder.gpkg</code>, and the provided license and description are attached to the data entry. Geodepot tries to retrieve the Spatial Reference System (SRS) and extent from the data and add it to the data item.</p> <pre><code>geodepot add \\\n  --license CC0 \\\n  --description \"A couple of buildings and a church in Delft for minimal testing.\" \\\n  wippolder \\\n  path/to/local/wippolder.gpkg\n</code></pre>"},{"location":"getting-started/#update-a-data-item","title":"Update a data item","text":"<p>To update an existing data item, we use the <code>add</code> command without passing an input file.</p> <pre><code>geodepot add \\\n  --description \"New description.\" \\\n  wippolder/wippolder.gpkg\n</code></pre>"},{"location":"getting-started/#view-the-repository-contents","title":"View the repository contents","text":"<p><code>geodepot list</code> prints the available cases and data items in the repository.</p> <pre><code>geodepot list\n</code></pre> <p>Returns:</p> <pre><code>wippolder\n        /wippolder.gpkg\n        /wippolder.las\n        /wippolder.tif\n3dbag\n        /3dbag_one.city.json\ntyler_debug\n        /3dtiles\n</code></pre> <p><code>geodepot show</code> prints the details of a case or data item.</p> <pre><code>geodepot show wippolder/wippolder.gpkg\n</code></pre> <p>Returns:</p> <pre><code>NAME=wippolder.gpkg\n\nDESCRIPTION=New description.\n\nformat=GPKG\ndriver=None\nlicense=CC0\nsha1=b1ec6506eb7858b0667281580c4f5a5aff6894b2\nchanged_by=My Name &lt;my@email.me&gt;\nextent=POLYGON ((85289.890625 447041.96875,85466.6953125 447041.96875,85466.6953125 447163.53125,85289.890625 447163.53125,85289.890625 447041.96875))\nsrs=PROJCS[\"Amersfoort / RD New\",GEOGCS[\"Amersfoort\",DATUM[\"Amersfoort\",SPHEROID[\"Bessel 1841\",6377397.155,299.1528128,AUTHORITY[\"EPSG\",\"7004\"]],AUTHORITY[\"EPSG\",\"6289\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4289\"]],PROJECTION[\"Oblique_Stereographic\"],PARAMETER[\"latitude_of_origin\",52.1561605555556],PARAMETER[\"central_meridian\",5.38763888888889],PARAMETER[\"scale_factor\",0.9999079],PARAMETER[\"false_easting\",155000],PARAMETER[\"false_northing\",463000],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"28992\"]]\n</code></pre>"},{"location":"getting-started/#collaboration","title":"Collaboration","text":"<p>Multiple users can access the same test data by adding the same Geodepot repository on a remote server as a 'remote' to their local repository. The users have read/write access to the remote, so they can update the remote with their local changes.</p> <p>When an empty repository is initialized, it does not reference any remotes. If you initialized the repository with a URL, the URL is added as a remote repository with the default name <code>origin</code>.</p> <p>A remote is added with <code>geodepot remote add</code>.</p> <pre><code>geodepot remote add origin ssh://user@server:/path/to/.geodepot\n</code></pre> <p>The supported protocols are HTTP, HTTPS, SSH, SFTP.  The <code>pull</code> and <code>push</code> commands only support the SSH and SFTP protocols.</p>"}]}